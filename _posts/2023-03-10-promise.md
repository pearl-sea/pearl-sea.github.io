---
layout: post
title: "Promise 객체"
categories: ["javascript"]
---

#### Promise 객체를 쓰는 이유

1. 비동기적으로 어떤 작업을 처리하기 위해
2. 그 작업을 처리했을때 성공했는지 실패했는지 표준화된 방법으로 확인하기 위해

#### 사용예시

1. Promise객체를 리턴하는 fetch 함수 실행
2. Promise객체는 pending 상태가 됨(대기중)

3-1. Promise객체가 fulfilled 상태가 되면 `then` 메서드로 등록한 콜백에서 Promise 객체, 또는 일반적인 값을 리턴  
3-2. Promise객체가 rejected 상태가 되면 `catch` 메서드로 등록한 콜백에서 작업 실패 정보가 담긴 에러 객체를 리턴

```jsx
fetch(
  "[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)"
).then((response) => {
  return response.json();
});
```

#### Promise chaning

promise객체에 `then` 메서드를 연속적으로 붙이는것을 의미하고  
비동기적인 작업을 순차적으로 실행시키기 위해,  
간결한 코드를 작성하기 위해 사용한다.  
`then` 메서드가 새로운 프로미스 객체를 리턴하기 때문에  
`then` 뒤에 또 `then`을 붙일 수 있다.
<br><br>

```jsx
fetch("https://jsonplaceholder.typicode.com/posts")
  .then((response) => {
    return response.json();
  })
  .then((result) => {
    const users = result;
    return users[0];
  })
  .then((user) => {
    const id = user.userId;
    const subject = user.title;
    const content = user.body;

    console.log(id);
    console.log(subject);
    console.log(content);
  });
```

#### catch 메서드

promise객체가 rejected 상태가 되었을때 실행하고 싶은 콜백을 적는 용도로 사용한다.  
then메서드의 가장 마지막에 붙이면 된다.

```jsx
.catch((error) => { console.log(error); })
```

catch 메서드는 사실 이것과 같다

```jsx
.then(undefined ,(error) => { console.log(error); })
```

#### finally 메서드

작업의 성공, 실패와 상관없이 실행하고 싶은 코드를 작성할수 있다.  
작업이 성공했는지, 안했는지 상관 없기 때문에 파라미터를 받지 않는다.  
catch 메서드 보다도 뒤에 쓴다.

```jsx
.finally(() => { console.log('작업 완료'); })
```

#### Promise 객체가 가진 상태와 결과

- 이전 메서드의 콜백에서 Promise 객체를 리턴 `⇒` then 메소드가 리턴했던 Promise 객체가 콜백이 리턴한 Promise 객체의 상태와 결과를 똑같이 따라 갖게 된다.
- 이전 메서드의 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴 `⇒` then메소드가 리턴했던 Promise 객체가 fulfilled 상태가 되고, 리턴된 값이 작업 성공 결과가 된다.
- 이전 메서드의 콜백에서 아무것도 리턴하지 않음 `⇒` then 메소드가 리턴했던 Promise 객체는 fulfilled 상태가 되고, 그 작업 성공 결과로 undefined를 갖게 된다.
- 이전 메서드의 콜백에서 에러가 발생했을때 `⇒` then 메소드가 리턴한 Promise 객체는 rejected 상태가 되고, 그 작업 실패 정보로 해당 Error 객체를 갖게 된다
